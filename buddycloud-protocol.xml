<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xmpp/extensions/xep.dtd' [
  <!ENTITY % ents SYSTEM 'xmpp/extensions/xep.ent'>
%ents;
]>
<?xml-stylesheet type='text/xsl' href='xmpp/extensions/xep.xsl'?>
<xep>
<header>
    <title>Channels for Social Networking</title>
    <abstract>This document describes a profile and conventions for usage of the PubSub protocol in the context of Social Networking.</abstract>
    &LEGALNOTICE;
    <number>xxxx</number>
    <status>ProtoXEP</status>
    <type>Standards Track</type>
    <sig>Standards</sig>
    <approver>Council</approver>
    <dependencies>
      <spec>XMPP Core</spec>
      <spec>XEP-0059 (Result Set Management)</spec>
      <spec>XEP-0060 (Publish-Subscribe)</spec>
    </dependencies>
    <supersedes/>
    <supersededby/>
    <shortname>NOT_YET_ASSIGNED</shortname>
    <author>
      <firstname>Simon</firstname>
      <surname>Tennant</surname>
      <email>simon@buddycloud.com</email>
      <jid>simon@buddycloud.com</jid>
    </author>

  <!--revision>
    <version>0.0.1</version>
    <date>2001-09-14</date>
    <initials>psa</initials>
    <remark><p>First draft.</p></remark>
  </revision-->
</header>
<section1 topic='Introduction' anchor='intro'>
  <p>
    buddycloud attempts to design a decentralised social product that solves users needs in a beautiful and efficient way.
  </p>
  <p>
    buddycloud builds on XMPP's native federation and asynchronous messaging to provide a decentralised sharing and communication network. The buddycloud ecosystem contains multiple [XMPP] components (for example: location butler, media server and directory) that together form a cohesive product and enable developers to build great products for their users.
  </p>
  <section2 topic='Glossary'>
    <dl>
      <dt>buddycloud channel
      </dt><dd>set of content-specific pubsub nodes per user (posts, geoloc, mood)
    </dd><dt>Home Server
  </dt><dd>hosts your channel nodes and is your inbox. The home server can do things on a behalf of user (like subscribing to a whitelisted channel))
</dd><dt>Remote Server
</dt><dd>hosts channels nodes of another user
</dd><dt>Follower
</dt><dd>a channel subscriber
</dd><dt>Moderator
</dt><dd>a channel follower with capabilities to also approve followers to topic channels and retract posts
</dd><dt>Producer
</dt><dd>the owner of a channel with the ability to add and remove moderators
</dd><dt>personal channel
</dt><dd>a channel about a user and named after their jid (e.g. hag66@shakespeare.lit)
</dd><dt>topic channel
</dt><dd>a channel based on a topic and carrying slightly different business logic (e.g. cauldron-recipees@shakespear.lit)
</dd>
</dl>

</section2>

<section3 topic='Associated documents'>

  <ul>
    <li>
      place management
    </li>
    <li>
      Channel Directory
    </li>
  </ul>

</section3>

</section1>


<section1 topic='buddycloud Logic'>
  <p>By prescribing sensible behavior that a server can enforce we avoid support issues on clients. "I've lost publishing rights to my own channel" or "I can't view a friends channel even though I am a moderator in that channel". Pub-sub is a great backend. A good user service built on it will prescribe sensible business logic that fits with a users mental model of what channels provide. We do that by adding a bit of business logic to the buddycloud server:
  </p>
  <ul>
    <li>
      channels nodes are owned by their jid. For example channeluser@example.com owns channel.example.com, node /user/channeluser@example.com/posts
    </li><li>the buddycloud server should maintain similar affiliations across .../posts, .../geo/current, .../geo/previous, .../geo/future and .../mood ie, if you follow a user, you also get to see their status.
  </li><li>only moderators and producers should be able to see channel outcasts (don't glorify bad behavior)
</li><li>use predictable channel addresses for web users.
</li><li>overview of channel services: <a href='http://example.com'>http://example.com</a>
</li><li>individual user channels<a href='http://example.com/user@example.com'>http://example.com/user@example.com</a>
</li>
</ul>
<p>Required nodes:
</p>
<p>
  Topic channel
</p>
<ul><li>
  posts
</li>
</ul>
<p>
  Personal channel
</p>
<ul>
  <li>
    posts
  </li><li>geo/current
</li><li>geo/previous
</li><li>geo/future
</li><li>mood
</li><li>subsciptions
</li>
</ul>

</section1>

<section1 topic='buddycloud Server Discovery'>
  <p>Server discovery happens per domain (the part of a JID that comes after the @ and before the /). Once a client has found its home buddycloud server, additional protocols are planned to leverage better connections and fuller caches of servers to find further remote buddycloud servers.
  </p><p>
  This is also used to check authority of a server for a user.
</p>


<section2 topic='Determining compatibility'>
  <p>Channels capable components MUST advertise their type in order to be used by other entities:
  </p>
  <![CDATA[<identity category="pubsub" type="channels"/>
]]>
</section2>

<section3 topic='Protocol flow'>

  <p>Using <a href='http://xmpp.org/extensions/xep-0030.html'>XEP-0030 Service Discovery:
  </a></p>
  <ul><li>
    Fetch items for the domain</li><li>
    Fetch info for each item</li><li>
    Pick the service with the following identity. Note that a response can contain multiple <identity/>> elements.
  </li></ul>

  <p><b>client discovers the component</b></p>
  <![CDATA[<identity category="pubsub" type="channels"/>]]>
  <p><b>the server replies with the component address</b></p>
  <![CDATA[... something here]]>
</section3>
</section1>

<section1 topic='The buddycloud Inbox'>

  <p>The inbox is an auxiliary service that can be discovered similar to the content-hosting service by pubsub/inbox. It takes care of receiving all notifications and synchronization while providing a one-shot MAM protocol for replaying them to clients. Therefore, users need only one presence authorization to that inbox.
  </p>

  <section2 topic='Inbox Discovery'>

    <p>Inbox components MUST advertise their type in order to be used by users:
    </p>

    <![CDATA[
      <identity category="pubsub" type="inbox"/>
    ]]>

  </section2>

  <section3 topic='Authorization'>

    <p>Any stanza except subscribe/unsubscribe do not convey identity of the end-user.
    </p>
    <p>
      The remote server has to check authority of the inbox/local server for the domain/user. It also has to check that at least one user of the inbox has permission to access the node.
    </p>
    <p>
      The inbox/local server has to synchronize subscriptions/affiliations to decide permissioning for its local users.
    </p>

  </section3>

  <section4 topic='Partition Detection'>

    <p>Channel services MUST also advertize all supported XMPP extensions in Service Discovery feature elements.
    </p>
    <p>
      Network partition detection has been designed for the notification-sending side. A service does not need to track delivery status of each message, but keeps track of remote services that were unreachable.
    </p>
    <p>
      When an inbox comes online after downtime, it has to retrieve all metadata and posts from user-subscribed nodes.
    </p>

    <p>In case of a network partition, it is the notification sender that detects unavailability of an inbox. It keeps track of the services that were offline, and periodically sends:
    </p>

    <![CDATA[
      <iq type="set" from="channels.denmark.lit" to="channels.shakespeare.lit">
        <you-missed-something xmlns="http://buddycloud.org/v1"/>
      </iq>
    ]]>

  </section4>

  <section5 topic='Timestamp perservation'>
    <p>Server-to-server syncing should always preserve items, config, subscription, and affiliation timestamps. Otherwise a resync would cause MAM to send too much to clients.
    </p>
  </section5>

</section1>


<section1 topic='Channel Management'>

  <section2 topic='Create a channel'>
    <p>If the user doesn't already have a channel, one can be created. The buddycloud server will then also setup the associated geoloc and mood nodes and ensure that the nodes have the correct permissions.
    </p>
    <![CDATA[
      <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="set">
        <query xmlns="jabber:iq:register"/>
      </iq>
    ]]>

    <![CDATA[
      <feature var='jabber:iq:register'/>
    ]]>
  </section2>

  <section3 topic='Edit Channel Metadata'>

    <p>Each channel must have the following metadata set
    </p>
		<table>
			<tbody>
				<tr>
					<th>
						Setting
					</th>
					<th>
						Field
					</th>
					<th>
						Example
					</th>
					<th>
						Notes
					</th>
					<th>
						Defaults
					</th>
				</tr>
				<tr>
					<td>
						Channel title
					</td>
					<td>
						pubsub#title
					</td>
					<td>
						My buddycloud channel
					</td>
					<td>
						displayed on a single line in clients
					</td>
					<td>
						user@example.org's buddycloud channel
					</td>
				</tr>
				<tr>
					<td>
						Channel description
					</td>
					<td>
						pubsub#description
					</td>
					<td>
						This is a channel about the things that I like to do.
					</td>
					<td>
						a multi-line description in clients
					</td>
					<td>
						empty
					</td>
				</tr>
				<tr>
					<td>
						Access model
					</td>
					<td>
						pubsub#access_model
					</td>
					<td>
						whitelist
					</td>
					<td>
						Who can view the channel?
						<ul>
							<li>
								<i>whitelist</i> means the channel is only viewable by followers, followers+post and moderators.
							</li>
							<li>
								<i>open</i> means anyone can view the channel
							</li>
							<li>
								<i>open</i> makes the channel web-viewable to anyone
							</li>
						</ul>
					</td>
					<td>
						Channel posts are open to the world, location is open to just friends. i.e.
						<ul>
							<li>.../posts - open
							</li>
							<li>.../mood - open
							</li>
							<li>.../geo/future - whitelist
							</li>
							<li>.../geo/current - whitelist
							</li>
							<li>.../geo/previous -whitelist
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>
						Default affiliation
					</td>
					<td>
						buddycloud#default_affiliation
					</td>
					<td>
						publisher
					</td>
					<td>
						What role do new followers have?<br>
						<br>
						<p>
							Spam problems in open topic channels mean that it's a good idea to only have new followrs unable to post until the channel producer understands the implications of anyone being able to post to their new channel or the new channel has enough moderators to remove spam posts.
						</p>
						<ul>
							<li>
								<i>publisher</i> (userspeak: "follower+post")
							</li>
							<li>
								<i>member</i> (userspeak:"follower")
							</li>
						</ul>
					</td>
					<td>
						<ul>
							<li>topic channels: follower
							</li>
							<li>personal channels: follower+post
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td>
						Channel type
					</td>
					<td>
						buddycloud#channel_type
					</td>
					<td>
						personal
					</td>
					<td>
						What type of channel is this?<br>
						<br>
						<ul>
							<li>
								<i>topic:</i> channels not associated with a topic.
							</li>
							<li>
								<i>personal:</i> channels about a jid
							</li>
						</ul>
					</td>
					<td>
						Create channel issued by a jid will first create a channel for that jid.
					</td>
				</tr>
				<tr>
					<td>
						Channel creation date
					</td>
					<td>
						pubsub#creation_date
					</td>
					<td>
						2011-01-31T23:59:42
					</td>
					<td>
						When the channel was created in <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601 time format</a>
					</td>
					<td>
						Sure an individual domain could spoof this. But that is sad. And pathetic.
					</td>
				</tr>
			</tbody>
		</table>
         <p>Upon update buddycloud server SHOULD send <a href="http://xmpp.org/extensions/xep-0060.html#owner-configure-process-notify">configuration notifications</a>.
      </p>

    </section3>

    <section4 topic='Synchronization'>
      <p>
        Via Message Archive Management:
      </p>
      <![CDATA[
        <iq type="get" id="sync1"
          from="francisco@denmark.lit/barracks"
          to="channels.denmark.lit">
          <query xmlns="urn:xmpp:archive#management"
           start="2010-06-07T00:00:00Z"
           end="2002-07-07T13:23:54Z"/>
         </iq>
       ]]>
       <p>
        The server now replays all notifications of the requested timespan, concluded by:
      </p>
      <![CDATA[
        <iq type="result" id="sync1"
          to="francisco@denmark.lit/barracks"
          from="channels.denmark.lit"/>
        ]]>
        <p>In those notifications the server must send even unsubscribed subscription states for full synchronization.
         It must also send subscription updates prior post  configuration state so that clients are aware of what to track (the user's subscriptions).
       </p>
     </section4>

     <section5 topic='Affiliation changes'>
      <p>
        When a client receives notification that its JID has an updated affiliation on a node, it should go out and refresh all data. This is because different roles see different users as described in Channel protocol. FIXME: this must also be done by inboxes!
      </p>

    </section5>

    <section6 topic='Subscribing to a channel'>


      <p>client to inbox
      </p>

      <![CDATA[
        <iq type="set"
          from="francisco@denmark.lit/barracks"
          to="channels.denmark.lit"
          id="sub1">
          <pubsub xmlns="http://jabber.org/protocol/pubsub">
            <subscribe node="/users/henry@shakespeare.lit/posts"
             jid="francisco@denmark.lit"/>
           </pubsub>
         </iq>
       ]]>

       <p>inbox to federated service
       </p>

       <![CDATA[
        <iq type="set"
          from="channels.denmark.lit"
          to="channels.shakespeare.lit"
          id="sub1">
          <pubsub xmlns="http://jabber.org/protocol/pubsub">
            <subscribe node="/users/henry@shakespeare.lit/posts"
             jid="francisco@denmark.lit"/>
             <actor xmlns="http://buddycloud.org/v1">francisco@denmark.lit</actor>
           </pubsub>
         </iq>
       ]]>
       <p>The remote service checks the actor for permission.</p> <p>The <i>@jid</i> attribute is purely decorative to comply with XEP-0060. It is not the actual notification listener (in that case the inbox instead of the user himself), but the user that wishes to subscribe. Use of the <i><actor/></i> element is more generic and applies to a variety of other requests that require authorization. </p><p>Upon successful subscription/unsubscription, the inbox must keep track if there's at least one subscription to the node with the inbox itself as listener, allowing it to answer read queries from only its cache. </p><p>Inbox then receives acknowledgement for subscription request, and relays it to the client: </p>



 <![CDATA[
  <iq type="result"
    from="channels.denmark.lit"
    to="francisco@denmark.lit/barracks"
    id="sub1">
    <pubsub xmlns="http://jabber.org/protocol/pubsub">
      <subscription
        node="/users/henry@shakespeare.lit/posts"
        jid="francisco@denmark.lit"
        subscription="subscribed"/>
      </pubsub>
    </iq>
  ]]>

  <p>Subscribed inboxes and clients are also notified:
  </p>

  <![CDATA[
    <message
      from="channels.shakespeare.lit"
      to="horatio@denmark.lit">
      <event xmlns="http://jabber.org/protocol/pubsub#event">
        <subscription node="/users/henry@shakespeare.lit" jid="francisco@denmark.lit" subscription="subscribed"/>
      </event>
    </message>
  ]]>

  <section7 topic='Temporary subscriptions'>

    <p><a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0060.html">XEP-0060</a> makes it possible to have <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0060.html#impl-tempsub">temporary subscriptions</a>.
  </p><p>Servers MUST deny temporary subscriptions to private channels (with a <i><not-allowed/></i> stanza). They SHOULD send unsubscription requests to federated services when the temporary subscribed becomes unavailable. A server MAY delete temporary subscriptions at any time: when restarting, when a channel becomes private, after a certain amount of time, etc. So clients SHOULD NOT consider temporary subscriptions to be ultimately reliable.
</p><p>When a client wants to subscribe temporarily to a channel, it MUST <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0060.html#subscriber-configure-subandconfig">subscribe and configure</a>.
</p><p>Client to inbox:
</p>
<![CDATA[
  <iq type="set"
    from="francisco@denmark.lit/barracks"
    to="channels.denmark.lit"
    id="sub1">
    <pubsub xmlns="http://jabber.org/protocol/pubsub">
      <subscribe node="/users/henry@shakespeare.lit/posts"
       jid="francisco@denmark.lit"/>
       <options node="/users/henry@shakespeare.lit/posts"
         jid="francisco@denmark.lit">
         <x xmlns="jabber:x:data" type="submit">
          <field var="FORM_TYPE" type="hidden">
            <value>http://jabber.org/protocol/pubsub#subscribe_options</value>
          </field>
          <field var="pubsub#expire"><value>presence</value></field>
        </x>
      </options>
    </pubsub>
  </iq>
]]>
<p>Inbox to federated service:</p>
<![CDATA[
  <iq type="set"
    from="channels.denmark.lit"
    to="channels.shakespeare.lit"
    id="sub1">
    <pubsub xmlns="http://jabber.org/protocol/pubsub">
      <subscribe node="/users/henry@shakespeare.lit/posts"
       jid="francisco@denmark.lit"/>
       <actor xmlns="http://buddycloud.org/v1">francisco@denmark.lit</actor>
       <options node="/users/henry@shakespeare.lit/posts"
         jid="francisco@denmark.lit">
         <x xmlns="jabber:x:data" type="submit">
          <field var="FORM_TYPE" type="hidden">
            <value>http://jabber.org/protocol/pubsub#subscribe_options</value>
          </field>
          <field var="pubsub#expire"><value>presence</value></field>
        </x>
      </options>
    </pubsub>
  </iq>
]]>
<p>If successful, the federated services sends an acknowledgement to the inbox, which relays it to the client. The <i><subscription/></i> element of this acknowledgement MUST include a <i>temporary</i> attribute:
</p>
<![CDATA[
  <iq type="result"
    from="channels.denmark.lit"
    to="francisco@denmark.lit/barracks"
    id="sub1">
    <pubsub xmlns="http://jabber.org/protocol/pubsub">
      <subscription
        node="/users/henry@shakespeare.lit/posts"
        jid="francisco@denmark.lit"
        subscription="subscribed"
        temporary="1"/>
      </pubsub>
    </iq>
  ]]>

  <p>Servers MAY also include the <i>temporary</i> attribute for non-temporary subscription acknowledgements.
</p><p>Servers MUST NOT send notifications about temporary subscriptions to federated services nor to the client, neither when subscribing nor when unsubscribing, as it wouldn't respect the privacy of people just visiting a channel without subscribing to it.
</p>

</section7>

</section6>

<section7 topic='Alter the default channel affiliation'>
  <p>What affiliation do new channel followers have?
  </p>
  <ul><li> publishers (userspeak: "follower+post")
  </li><li> subscribers (userspeak: "follower")
</li></ul>
<![CDATA[
  <iq type="set"
    from="channeluser@example.com/ChannelCompatibleClient"
    to="channelserver.example.com"
    id="create1">
    <pubsub xmlns="http://jabber.org/protocol/pubsub">
     <create node="/user/channeluser@example.com"/>
     <configure>
      <x xmlns="jabber:x:data" type="submit">
       <field var="FORM_TYPE" type="hidden">
        <value>http://jabber.org/protocol/pubsub#node_config</value>
      </field>
      <field var="pubsub#publish_model"><value>publishers</value></field>
    </x>
  </configure>
</pubsub>
</iq>

]]>

</section7>

<section8 topic='Anonymous channel access'>
  <p>Anonymous channel access is used by non-authenticated clients such as webclients or web widgets.
  </p><p>A service should discover an acting entity and deny any modifying requests if the entity has an identity of <i>account/anonymous</i> according to <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0175.html#disco">XEP-0175 Discovery</a>.
</p><p>Anonymous users may do <a href="https://buddycloud.org/wiki/XMPP_XEP#Temporary_subscriptions">temporary subscriptions</a> to open channels. These subscriptions must be removed by the servers once the last resource of the anonymous user has sent unavailable presence.
</p>
</section8>


</section1>
<section1 topic='Post management'>
  <section2 topic='Content normalization'>
	  <p>
	  	When posting to a channel a server MUST apply the following rules to the ATOM payload:
	  </p>
	  <ul>
	  	<li>The entry/author/uri MUST be set to the acct: account of the entity that is actually posting to the channel. This shoudl be the bare jid.
	  	</li>
	  	<li>Upon a new entry the entry/published timestamp MUST be set to the current server time (often more accurate than client clock)
	  	</li>
	  	<li>Upon overwriting an existing entry, the entry/published SHOULD be copied from the old version and entry/updated SHOULD be set to the current server time
	  	</li>
	  	<li>The entry/id element SHOULD be updated to reflect the PubSub content model
	  	</li>
	  	<li>Any conversation thread information MAY be checked for existing references, and possibly deny posting with missing context
	  	</li>
	  	<li>The entry/content MAY be used for spam filtering, especially for posts from non-channel-owners
	  	</li>
	  	<li>Missing Activity Streams constructs may be replaced by verb post or comment (depending on presence of thr:in-reply-to)
	  	</li>
	  </ul>
	  <p>
	  	Clients (especially in Web browsers) SHOULD NOT display rich content of entry/content[@type='html' or @type='xhtml'] without sanitizing markup and scrubbing JavaScript
	  </p>
	  <ul>
	  	<li>If a server provides channel data via HTTP, it MAY add entry/link[@rel='alternate'] pointers to these representations
	  	</li>
	  </ul>
	  <p>
	  	Note: Add something about post size restrictions
	  </p>
	  <p>
	  	Note: in a decentralized system not only content-hosting servers may validate content.
	  </p>
 
</section2>

<section3 topic='Create a post'>
  <p>Posting to a channel implies a role of "follower+post, moderator or producer"
  </p>
  <![CDATA[
    <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="set" id="publish:20"> 
      <pubsub xmlns="http://jabber.org/protocol/pubsub"> 
       <publish node="/user/koski@buddycloud.com/posts"> 
        <item> 
         <entry xmlns="http://www.w3.org/2005/Atom" xmlns:activity="http://activitystrea.ms/spec/1.0/"> 
          <published>2010-01-06T21:41:32Z</published> 
          <author> 
           <name>koski@buddycloud.com</name> 
           <jid xmlns="http://buddycloud.com/atom-elements-0">koski@buddycloud.com</jid> 
         </author> 
         <content type="text">Test</content> 
         <geoloc xmlns="http://jabber.org/protocol/geoloc"> 
           <text>Paris, France</text> 
           <locality>Paris</locality> 
           <country>France</country> 
         </geoloc> 
         
         <activity:verb>post</activity:verb>
         <activity:object>
          <activity:object-type>note</activity:object-type>
        </activity:object>
      </entry> 
    </item> 
  </publish> 
</pubsub> 
</iq>
]]>
<p>
  The activity:object-type should be comment if the entry is a reply to another post.
</p>
<p>
  The inbox server will relay the stanza to the hosting component along with <actor/> information.
</p>
</section3>
<section4 topic='Receive a post'>
  <p>
    Subscribed inboxes are always notified. Online clients automatically receive new posts from the inbox
  </p>
  <![CDATA[
    <message type="headline" id="bc:GfLwH" from="channelserver.example.com" to="31941515521289471453412508@anon.buddycloud.com/2906694851289471453813745"> 
      <event xmlns="http://jabber.org/protocol/pubsub#event"> 
        <items node="/user/channeluser@example.com/posts"> 
          <item id="1291048810046"> 
            <entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"> 
              <author> 
                <name>Dirk</name> 
                <jid xmlns="http://buddycloud.com/atom-elements-0">fahrertuer@example.com</jid> 
                <affiliation xmlns="http://buddycloud.com/atom-elements-0">moderator</affiliation> 
              </author> 
              <content type="text">A comment, wondering what all this testing does</content> 
              <published>2010-11-29T16:40:10Z</published> 
              <updated>2010-11-29T16:40:10Z</updated> 
              <id>/user/channeluser@example.com/posts:1291048810046</id> 
              <geoloc xmlns="http://jabber.org/protocol/geoloc"> 
                <text>Bremen, Germany</text> 
                <locality>Bremen</locality> 
                <country>Germany</country> 
              </geoloc> 
              <thr:in-reply-to ref="1291048772456"/> 
            </entry> 
          </item> 
        </items> 
      </event> 
    </message>
  ]]>
</section4>

<section5 topic='Retrieve a post'>
  <p>
    Node items are ordered newest first. The Result Set Management elements after and before are not related to timestamps but this ordering!
  </p>
  <p>
    Client sends:
  </p>
  <![CDATA[
    <iq type="get"
      from="channeluser@example.com/KillerApp"
      to="channelserver.example.com"
      id="items1">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <items node="/user/kitteh@example.com/posts"/>
      </pubsub>
    </iq>
  ]]>
  <p>
    Server responds:
  </p>
  <![CDATA[
    <iq type="result"
      from="channelserver.example.com"
      to="channeluser@example.com/KillerApp"
      id="items1">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <items node="/user/kitteh@example.com/posts">
          <item id="1291048810046"> 
            <entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"> 
              <author> 
                <name>Dirk</name> 
                <jid xmlns="http://buddycloud.com/atom-elements-0">fahrertuer@example.com</jid> 
                <affiliation xmlns="http://buddycloud.com/atom-elements-0">moderator</affiliation> 
              </author> 
              <content type="text">A comment, wondering what all this testing does</content> 
              <published>2010-11-29T16:40:10Z</published> 
              <updated>2010-11-29T16:40:10Z</updated> 
              <id>/user/channeluser@example.com/posts:1291048810046</id> 
              <geoloc xmlns="http://jabber.org/protocol/geoloc"> 
                <text>Bremen, Germany</text> 
                <locality>Bremen</locality> 
                <country>Germany</country> 
              </geoloc> 
              <thr:in-reply-to ref="1291048772456"/> 
            </entry> 
          </item>
          <!-- [more items...] -->
          <item id="1131048810046"> 
            <entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"> 
              <author> 
                <name>Kittycat</name> 
                <jid xmlns="http://buddycloud.com/atom-elements-0">kitteh@example.com</jid> 
                <affiliation xmlns="http://buddycloud.com/atom-elements-0">owner</affiliation> 
              </author> 
              <content type="text">I"m in ur channel, meowing federatedly</content> 
              <published>2009-08-12T16:40:10Z</published> 
              <id>/user/channeluser@example.com/posts:1131048810046</id> 
              <geoloc xmlns="http://jabber.org/protocol/geoloc"> 
                <text>Home basket</text> 
                <locality>Munich</locality> 
                <country>Germany</country> 
              </geoloc> 
            </entry> 
          </item>
        </items>
        <set xmlns="http://jabber.org/protocol/rsm">
          <first>1291048810046</first>
          <last>1131048810046</last>
          <count>19827</count>
        </set>
      </pubsub>
    </iq>
  ]]>

  <p>
    Client can then request older items for pagination or filling its cache:
  </p>

  <![CDATA[
    <iq type="get"
      from="channeluser@example.com/KillerApp"
      to="channelserver.example.com"
      id="items2">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <items node="/user/kitteh@example.com/posts"/>
        <set xmlns="http://jabber.org/protocol/rsm">
          <max>1200</max>
          <after>1131048810046</after>
        </set>
      </pubsub>
    </iq>
  ]]>
  <p>
    Result Set Management is strongly needed for chunkifying information. Even if a user is requesting 10000 items, a buddycloud server should never send stanzas exceeding 64KB, or else XMPP servers will kill the (component or s2s) connection.
  </p>

</section5>

<section6 topic='Retrieve recent posts from all subscribed channels'>
  <p>Clients that need to access recent posts in all the followed channels may use the quick synchronization mechanism. This can only be used by authenticated users.
  </p>
  <p>
    Client sends:
  </p>
  <![CDATA[
    <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="get" id="ri1">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <recent-items xmlns="http://buddycloud.org/v1"
          since="2012-12-04T23:36:51.123Z"
          max="50"/>
        </pubsub>
      </iq>
    ]]>

    <p>
      The servers responds with items from the subscribed channels:
    </p>
    <ul>
      <li>items from the /posts nodes only
      </li><li>updated after since, newest items first, required
    </li><li>at most max per channel, required
  </li><li>RSM must be used to page through results
</li></ul>

</section6>
<section7 topic='Retrieve all replies from a single post'>
  <p>
    This stanza retrieve all replies from a single post. It is useful in cases the user has new replies in old posts, so that he does not need to look down the node stream to fetch old replies. This can only be used by authenticated users. The attrs node and item_id are mandatory.
  </p>

  <p>
    Client sends:
  </p>


  <![CDATA[
    <iq type="get" from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" id="ri1">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <replies xmlns="http://buddycloud.org/v1" node="/user/channeluser@example.com/posts" item_id="38efced3-5462-49af-ba83-9f1d0a753a93"/>
      </pubsub>
    </iq>
  ]]>
  <p>
    The servers responds with replies to that item
  </p>
  <ul><li>
    RSM must be used to page through results
  </li></ul>


  <![CDATA[
    <iq type="result"
      from="channelserver.example.com"
      to="channeluser@example.com/ChannelCompatibleClient"
      id="ri1">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <items>
          <item id="1291048810046">
            <entry>...</entry>
          </item>
          <item id="1287390194809">
            <entry>...</entry>
          </item>
          ...
        </items>
        <set xmlns="http://jabber.org/protocol/rsm">
          <first>/user/kitteh@example.com/posts;1291048810046</first>
          <last>/user/tut@example.com/posts;1131048810046</last>
          <count>19827</count>
        </set>
      </pubsub>
    </iq>
  ]]>

</section7>

<section8 topic='Delete a post'>
  <p>The client sends
  </p>

  <![CDATA[
    <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="set" id="retractitem:32"> 
      <pubsub xmlns="http://jabber.org/protocol/pubsub"> 
        <retract node="/user/channeluser@example.com/posts" notify="1"> 
          <item id="1291048772456"/> 
        </retract> 
      </pubsub> 
    </iq>
  ]]>

  <p>Server replies
  </p>

  <![CDATA[
    <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="result" id="retractitem:32"/>
  ]]>
  <p>A retraction message is sent to all online clients, along with an Atom tombstone to replace the deleted post
  </p>
  <![CDATA[
    <message from="channelserver.example.com" id="bc:MGV3B" to="imranraza@example.com"> 
      <event xmlns="http://jabber.org/protocol/pubsub#event"> 
        <items node="/user/channeluser@example.com/posts"> 
          <retract id="1291048772456"/> 
          <item id="1291048772456">
            <deleted-entry xmlns="http://purl.org/atompub/tombstones/1.0" ref="xmpp:channels.example.com?pubsub;action=retrieve;node=/user/channeluser@example.com/posts;item=1291048772456" when="2012-07-01T15:08:32.950Z">
              <updated>2012-07-01T15:08:32.950Z</updated>
              <id xmlns="http://www.w3.org/2005/Atom">1291048772456</id>
              <link xmlns="http://www.w3.org/2005/Atom" href="xmpp:channels.example.com?pubsub;action=retrieve;node=/user/channeluser@example.com/posts;item=1291048772456" rel="self"/>
              <published xmlns="http://www.w3.org/2005/Atom">2012-07-01T15:08:30.922Z</published>
              <object xmlns="http://activitystrea.ms/spec/1.0/">
                <object-type>comment</object-type>
              </object>
              <verb xmlns="http://activitystrea.ms/spec/1.0/">post</verb>
            </deleted-entry>
          </item>
        </items> 
      </event> 
    </message>
  ]]>


</section8>


<section9 topic='buddycloud Firehose'>
  <p>
    The /firehose node is a realtime relay feed of all posts from open channels and can be used with feed aggregation services like Superfeedr.
  </p>

</section9>

</section1>
<!--xyz-->


<!--abc-->
<section1 topic='Follower Management'>

  <section2 topic='Follower Roles'>
    <p>The following roles exist in buddycloud
    </p>

	<table>
		<tbody>
			<tr>
				<th>
					Users see
				</th>
				<th>
					Reported as
				</th>
				<th>
					Capabilities
				</th>
				<th>
					Notes
				</th>
			</tr>
			<tr>
				<td>
					producer
				</td>
				<td>
					owner
				</td>
				<td>
					publish and delete anyone's posts
				</td>
				<td></td>
			</tr>
			<tr>
				<td>
					moderator
				</td>
				<td>
					moderator
				</td>
				<td>
					posts can remove posts and approve new followers
				</td>
				<td></td>
			</tr>
			<tr>
				<td>
					follower+post
				</td>
				<td>
					publisher
				</td>
				<td>
					read and post
				</td>
				<td>
					default role for new followers
				</td>
			</tr>
			<tr>
				<td>
					follower
				</td>
				<td>
					member
				</td>
				<td>
					read-only
				</td>
				<td></td>
			</tr>
			<tr>
				<td>
					banned
				</td>
				<td>
					outcast
				</td>
				<td>
					no posting rights.<br>
					<br>
					new follow requests from this user are also ignored<br>
					<br>
				</td>
				<td>
					To avoid "glorification of the bad", only the channel producer and moderators should see the banned list.
				</td>
			</tr>
		</tbody>
	</table>

  <p>
    Servers should enforce the following rules for channel followers:
  </p>
  <ul><li>
    Each channel follower should be just listed once (a user cannot be a channel owner and banned for example)
  </li><li>Each channel can have just one owner
</li><li>If the channel is a personal channel then that owner must match the channel JID
</li></ul><p>Query for information about a user
</p><p>
The client sends:
</p>

<![CDATA[
  <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="get" id="metadata1"> 
    <query xmlns="http://jabber.org/protocol/disco#info" node="/user/channeluser@example.com"/> 
  </iq>
]]>
<p>
  The server replies:
</p>

<![CDATA[
  <iq type="result" id="metadata1" from="channelserver.example.com" to="channeluser@example.com/ChannelCompatibleClient"> 
    <query xmlns="http://jabber.org/protocol/disco#info" node="/user/channeluser@example.com"> 
      <identity category="pubsub" type="channel"/> 
      <feature var="http://jabber.org/protocol/pubsub"/> 
      <x xmlns="jabber:x:data" type="result"> 
        <field var="FORM_TYPE" type="hidden"> 
          <value>http://jabber.org/protocol/pubsub#meta-data</value> 
        </field> 
        <field var="buddycloud#subscribers-count" label="Number of subscribers" type="text-single"> 
          <value>23</value> 
        </field> 
        <field var="buddycloud#subscriptions-count" label="Number of channels the user is subscribed to" type="text-single"> 
          <value>42</value> 
        </field> 
        <field var="buddycloud#moderates-count" label="Number of channels the user moderates" type="text-single"> 
          <value>8</value> 
        </field> 
        <field var="buddycloud#produces-count" label="Number of channels the user posts in" type="text-single"> 
          <value>13</value> 
        </field> 
      </x> 
    </query> 
  </iq>
]]>
</section2>
<section3 topic='Retrieve followers'>
  <p>
    Query for the followers of a channel.
  </p><p>
  The client sends:
</p>
<![CDATA[
  <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="get" id="26:85"> 
    <pubsub xmlns="http://jabber.org/protocol/pubsub#owner"> 
      <affiliations node="/user/channeluser@example.com/posts"/> 
      <set xmlns="http://jabber.org/protocol/rsm"> 
        <max>30</max> 
      </set> 
    </pubsub> 
  </iq>
  The server replies with a list of users and their affiliations:

  <iq type="result" id="26:85" from="channelserver.example.com" to="channeluser@example.com/ChannelCompatibleClient"> 
    <pubsub xmlns="http://jabber.org/protocol/pubsub#owner"> 
      <affiliations node="/user/channeluser@example.com/posts"> 
        <affiliation jid="1753416401288704184459819@anon.buddycloud.com" affiliation="member"/> 
        <!-- anon users are usually bosh based read-only web views --> 
        <affiliation jid="akioh@anotherdomain.com" affiliation="publisher"/> 
      </affiliations> 
    </pubsub> 
  </iq>
]]>
<ul><li>
  Change the affiliation of a channel follower</li></ul>
</section3>

<section4 topic='Following'>
  <p>
    In order to make a user's subscription affiliation state on remote servers discoverable, a node on the home server needs to be filled. Use item ids by remote user to selectively update.
  </p>

  <![CDATA[
    <iq from="channeluser@example.com/ChannelCompatibleClient" to="channelserver.example.com" type="set" id="publish:20">
      <pubsub xmlns="http://jabber.org/protocol/pubsub">
       <publish node="/user/channeluser@example.com/subscriptions">
        <item id="koski@buddycloud.com">
          <query xmlns="http://jabber.org/protocol/disco#items" xmlns:pubsub="http://jabber.org/protocol/pubsub" xmlns:atom="http://www.w3.org/2005/Atom">
            <item jid="sandbox.buddycloud.com"
              node="/user/koski@buddycloud.com/posts"
              pubsub:affiliation="publisher">
              <atom:updated>2010-12-26T17:30:00Z</atom:updated>
            </item>
            <item jid="sandbox.buddycloud.com"
              node="/user/koski@buddycloud.com/geo/future"/>
              <item jid="sandbox.buddycloud.com"
                node="/user/koski@buddycloud.com/geo/current"/>
                <item jid="sandbox.buddycloud.com"
                  node="/user/koski@buddycloud.com/geo/previous"/>
                  <item jid="sandbox.buddycloud.com"
                    node="/user/koski@buddycloud.com/mood"
                    pubsub:affiliation="member"/>
                  </query>
                </item>
              </publish>
            </pubsub>
          </iq>

        ]]>
        <p>Clients may also use this information to accelerate discovery of remote servers/subscriptions. Actual states as defined by the hosting (remote) server should be synchronized nevertheless.
        </p><p>
        The atom:updated element does not serve synchronization (which is based on client-side cache state). It indicates the timestamp of the last post a user read for showing number of unread items.
      </p>

    </section4>

    <section5 topic='Follower Authorization'>
      <p>Subscription changes to a state of pending are not included in standard subscription change notifications.
      </p>
      <p>
        Under an access model of authorize, the PubSub mechanisms are used. Contrary to iq requests, actor information is put in a form field:
      </p>
      <![CDATA[
        <message to="inbox.denmark.lit" from="channels.denmark.lit">
          <x xmlns="jabber:x:data" type="form">
            <title>PubSub subscriber request</title>
            <field var="FORM_TYPE" type="hidden">
              <value>http://jabber.org/protocol/pubsub#subscribe_authorization</value>
            </field>
            <field var="pubsub#node" type="text-single" label="Node ID">
              <value>/user/hamlet@denmark.lit/posts</value>
            </field>
            <field var="pubsub#subscriber_jid" type="jid-single" label="Subscriber Address">
              <value>spy@nsa.gov</value>
            </field>
            <field var="pubsub#allow" type="boolean"
             label="Allow spy@nsa.gov to subscribe to the posts of hamlet@denmark.lit?">
             <value>false</value>
           </field>
         </x>
       </message>
       <message from="inbox.denmark.lit" to="channels.denmark.lit" id="approve1">
        <x xmlns="jabber:x:data" type="submit">
          <field var="FORM_TYPE" type="hidden">
            <value>http://jabber.org/protocol/pubsub#subscribe_authorization</value>
          </field>
          <field var="pubsub#node">
            <value>/user/hamlet@denmark.lit/posts</value>
          </field>
          <field var="pubsub#subscriber_jid">
            <value>spy@nsa.gov</value>
          </field>
          <field var="pubsub#allow">
           <value>false</value>
         </field>
         <field var="buddycloud#actor">
           <value>hamlet@denmark.lit</value>
         </field>
       </x>
     </message>
   ]]>

 </section5>
</section1>

</xep>
