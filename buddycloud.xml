<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE xep SYSTEM 'xep.dtd' [
<!ENTITY % ents SYSTEM 'xep.ent'>
%ents;
<!ENTITY actor "&lt;actor/&gt;">
<!ENTITY invalidactor "&lt;invalid-actor/&gt;">
<!ENTITY invalidnode "&lt;invalid-node/&gt;">
]>
<?xml-stylesheet type='text/xsl' href='xep.xsl'?>
<xep>
	<header>
		<title>Buddycloud Channels</title>
		<abstract>This document describes a profile and conventions for usage
			of the PubSub protocol in the context of a new type of communication.</abstract>
		<legal>
			<copyright>This XMPP Extension Protocol is copyright (c) 1999 - 2010
				by the XMPP Standards Foundation (XSF).
			</copyright>
			<permissions> Permission is hereby granted, free of charge, to any
				person obtaining a copy of this specification (the
				&quot;Specification&quot;), to make use of the Specification without
				restriction, including without limitation the rights to implement
				the Specification in a software program, deploy the Specification in
				a network service, and copy, modify, merge, publish, translate,
				distribute, sublicense, or sell copies of the Specification, and to
				permit persons to whom the Specification is furnished to do so,
				subject to the condition that the foregoing copyright notice and
				this permission notice shall be included in all copies or
				substantial portions of the Specification. Unless separate
				permission is granted, modified works that are redistributed shall
				not contain misleading information regarding the authors, title,
				number, or publisher of the Specification, and shall not claim
				endorsement of the modified works by the authors, any organization
				or project to which the authors belong, or the XMPP Standards
				Foundation. 
			</permissions>
			<warranty> ## NOTE WELL: This Specification is provided on an
				&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
				KIND, express or implied, including, without limitation, any
				warranties or conditions of TITLE, NON-INFRINGEMENT,
				MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. In no event
				shall the XMPP Standards Foundation or the authors of this
				Specification be liable for any claim, damages, or other liability,
				whether in an action of contract, tort, or otherwise, arising from,
				out of, or in connection with the Specification or the
				implementation, deployment, or other use of the Specification. ## 
			</warranty>
			<liability> In no event and under no legal theory, whether in tort
				(including negligence), contract, or otherwise, unless required by
				applicable law (such as deliberate and grossly negligent acts) or
				agreed to in writing, shall the XMPP Standards Foundation or any
				author of this Specification be liable for damages, including any
				direct, indirect, special, incidental, or consequential damages of
				any character arising out of the use or inability to use the
				Specification (including but not limited to damages for loss of
				goodwill, work stoppage, computer failure or malfunction, or any and
				all other commercial damages or losses), even if the XMPP Standards
				Foundation or such author has been advised of the possibility of
				such damages.
			</liability>
			<conformance>
				This XMPP Extension Protocol has been contributed in full
				conformance with the XSF's Intellectual Property Rights Policy (a
				copy of which may be found at &lt;
				<link url='http://www.xmpp.org/extensions/ipr-policy.shtml'>http://www.xmpp.org/extensions/ipr-policy.shtml</link>
				&gt; or obtained by writing to XSF, P.O. Box 1641, Denver, CO 80201
				USA). 
			</conformance>
		</legal>
		<number>xxxx</number>
		<status>ProtoXEP</status>
		<type>Standards Track</type>
		<sig>Standards</sig>
		<approver>Council</approver>
		<dependencies>
			<spec>XMPP Core</spec>
			<spec>XEP-0059</spec>
			<spec>XEP-0060</spec>
			<spec>XEP-0313</spec>
			<spec>XEP-0255</spec>
			<spec>XEP-0107</spec>
		</dependencies>
		<supersedes />
		<supersededby />
		<shortname>NOT_YET_ASSIGNED</shortname>
		<author>
			<firstname>Simon</firstname>
			<surname>Tennant</surname>
			<email>simon@buddycloud.com</email>
			<jid>simon@buddycloud.com</jid>
		</author>
		<author>
			<firstname>Ashley</firstname>
			<surname>Ward</surname>
			<email>ashley.ward@surevine.com</email>
			<jid>ashley.ward@surevine.com</jid>
		</author>
		<revision>
			<version>0.0.1</version>
			<date>2014-01-xx</date>
			<initials>sdt</initials>
			<remark>
				<p>First draft.</p>
			</remark>
		</revision>
	</header>
	<section1 topic='Buddycloud Introduction' anchor='intro'>
		<p>Buddycloud channels is a decentralised communication protocol that
			enables synchronised communication in the form of channels between
			Buddycloud-enabled domains.
		</p>
		<p>Buddycloud channels build on XMPP's native federation and
			asynchronous messaging to provide a decentralised sharing and
			communication network. The Buddycloud ecosystem contains multiple
			[XMPP] components (for example: location-butler, media-server and
			channel-directory) that work together and enable developers to build
			new communication products.
		</p>
	</section1>
	<section1 topic='Requirements' anchor='reqs'>
	</section1>
	<section1 topic='Glossary' anchor='glossary'>
		<dl>
			<di>
				<dt>Channel</dt>
				<dd>A
					collection of content-specific &xep0060;
					Nodes (posts, geoloc, public-key) 
				</dd>
			</di>
			<di>
				<dt>Channel Server</dt>
				<dd>An XMPP component which hosts channel nodes and provides an
					interface conforming to this document to allow access to them via
					XMPP.
				</dd>
			</di>
			<di>
				<dt>Home Server</dt>
				<dd>The channel server which hosts a user's personal channel nodes
					and contains their Inbox. The home server operates on behalf of
					users (for example subscribing to a whitelisted channel))
				</dd>
			</di>
			<di>
				<dt>Follower</dt>
				<dd>A Channel subscriber</dd>
			</di>
			<di>
				<dt>Moderator</dt>
				<dd>A channel follower with capabilities to also approve followers
					to topic channels and retract posts
				</dd>
			</di>
			<di>
				<dt>Producer</dt>
				<dd>the owner of a channel with the ability to add and remove
					moderators
				</dd>
			</di>
			<di>
				<dt>Inbox</dt>
				<dd> Service on the Entity's Home Server which subscribes to nodes
					on the Entity's behalf, and may cache node data and provide an
					ability to replay recent messages.
				</dd>
			</di>
			<di>
				<dt>Personal Channel</dt>
				<dd> A Channel about an Entity and named after their jid (e.g.
					romeo@montague.lit)
				</dd>
			</di>
			<di>
				<dt>Topic Channel</dt>
				<dd> A Channel based on an arbitrary topic and carrying slightly
					different business logic (e.g. balconies@capulet.lit)
				</dd>
			</di>
		</dl>
	</section1>
	<section1 topic='Preliminaries' anchor='preliminaries'>
		<section2 topic='Business Logic' anchor='preliminaries-businesslogic'>
			<p>By prescribing sensible behavior that a server can enforce we
				avoid support issues on clients. "I've lost publishing rights to my
				own channel" or "I can't view a friends channel even though I am a
				moderator in that channel". Pub-sub is a great backend. A good user
				service built on it will prescribe sensible business logic that fits
				with a users mental model of what channels provide. We do that by
				adding a bit of business logic to the Buddycloud server:
			</p>
			<ul>
				<li>
					Personal Channel Nodes are always owned by their JID. The server
					MUST NOT allow the ownership to be altered. For example:
					<em>juliet@capulet.lit</em>
					owns
					<em>channel.capulet.lit</em>
					, node
					<em>/user/juliet@capulet.lit/posts</em>
				</li>
				<li>
					The Buddycloud server must maintain similar affiliations across
					<em>.../posts</em>
					,
					<em>.../geo/current</em>
					,
					<em>.../geo/previous</em>
					,
					<em>.../geo/future</em>
					and
					<em>.../mood</em>
					ie, if you follow a user, you also get to see their status.
				</li>
				<li>Only owners, moderators and producers should be able to see
					channel outcasts (don't glorify bad behavior)
				</li>
			</ul>
		</section2>
		<section2 topic='The Buddycloud Inbox'>
			<p>The inbox is an auxiliary service that can be discovered similar
				to the content-hosting service by pubsub/inbox. It takes care of
				receiving all notifications and synchronization while providing a
				one-shot MAM protocol for replaying them to clients. Therefore,
				users need only one presence authorization to that inbox.
			</p>
			<section3 topic='Inbox Discovery'>
				<p>Inbox components MUST advertise their type in order to be used by
					users.
				</p>
				<example><![CDATA[
<identity category="pubsub" type="inbox"/>
]]> </example>
			</section3>
			<section3 topic='Inbox Authorization'>
				<p>Any stanza except subscribe/unsubscribe do not convey identity of
					the end-user.
				</p>
				<p>The remote server must check authority of the inbox/home server
					for the domain/user. The remote server must also has to check that
					at least one user of the inbox has permission to access the node.
				</p>
				<p>The inbox/home server must synchronize subscriptions/affiliations
					to decide permissioning for its local users.
				</p>
			</section3>
			<section3 topic='Partition Detection'>
				<p>Channel services MUST also advertize all supported XMPP
					extensions in Service Discovery feature elements.
				</p>
				<p>Network partition detection has been designed for the
					notification-sending side. A service does not need to track
					delivery status of each message, but keeps track of remote services
					that were unreachable.
				</p>
				<p>When an inbox comes online after downtime, it has to retrieve all
					metadata and posts from user-subscribed nodes.
				</p>
				<p>In case of a network partition, it is the notification sender
					that detects unavailability of an inbox. It keeps track of the
					services that were offline, and periodically sends.
				</p>
				<example>
<![CDATA[
<iq type="set" from="buddycloud.montague.lit" to="buddycloud.capulet.lit">
<you-missed-something xmlns="http://buddycloud.org/v1"/>
		</iq>
		]]> </example>
			</section3>
		</section2>
		<section2 topic="Channel Nodes" anchor='preliminaries-channelnodes'>
			<p>A Channel consists of a number of PubSub Nodes with well-known ids
			</p>
			<section3 topic="Channel NodeIDs" anchor='preliminaries-channelnodes-ids'>
				<p>
					Node IDs are constructed as
					<strong>"/user/&lt;JID&gt;/&lt;node type&gt;"</strong>
				</p>
				<dl>
					<di>
						<dt>JID</dt>
						<dd>This is the Bare JID of the channel, in the form
							'channel@domain.tld'
						</dd>
					</di>
					<di>
						<dt>Node Type</dt>
						<dd>
							See
							<link url='#preliminaries-channelnodes-types'>Node Types</link>
						</dd>
					</di>
				</dl>
			</section3>
			<section3 topic="Node Types" anchor='preliminaries-channelnodes-types'>
				<p>A channel is split into various nodes, each of which contains a
					different set of data relating to the channel. The following table
					describes the currently defined node types.
				</p>
				<table caption="Node Types">
					<tr>
						<th rowspan="2">Node Type</th>
						<th colspan="2">Required</th>
						<th rowspan="2">Description</th>
					</tr>
					<tr>
						<th>Personal Channels</th>
						<th>Topic Channels</th>
					</tr>
					<tr>
						<td>posts</td>
						<td>Yes</td>
						<td>Yes</td>
						<td>The main node for the channel, containing the primary activity
							stream</td>
					</tr>
					<tr> <!-- check if it's geo/current or geo-current -->
						<td>geo/current</td>
						<td>Yes</td>
						<td>No</td>
						<td>A XEP-0255 compliant feed of the User's current location</td>
					</tr>
					<tr>
						<td>geo/previous</td>
						<td>Yes</td>
						<td>No</td>
						<td>A XEP-0255 compliant feed of the User's previous location</td>
					</tr>
					<tr>
						<td>geo/future</td>
						<td>Yes</td>
						<td>No</td>
						<td>A XEP-0255 compliant feed of the User's future location</td>
					</tr>
					<tr>
						<td>subscriptions</td>
						<td>Yes</td>
						<td>No</td>
						<td>A list of the user's public subscriptions</td>
					</tr>
				</table>
			</section3>
		</section2>
		<section2 topic="Channel Metadata" anchor="preliminaries-channelmetadata">
			<p>Channel metadata is stored as node metadata against the /posts
				node of the channel.
			</p>
			<p>Most
				metadata fields used for Channels are already defined in &xep0060;.
				The relevant ones are listed below. 
			</p>
			<table caption="Channel Metadata Fields">
				<tr>
					<th>Metadata</th>
					<th>Field</th>
					<th>Example</th>
					<th>Notes</th>
					<th>Defaults</th>
				</tr>
				<tr>
					<td>Channel Title</td>
					<td>pubsub#title</td>
					<td>"Juliet's musings"</td>
					<td>Should be a brief single sentence</td>
					<td>"juliet@capulet.lit's Buddycloud channel"</td>
				</tr>
				<tr>
					<td>Channel Description</td>
					<td>pubsub#description</td>
					<td>"This is a channel about the things that I like to do."</td>
					<td>A longer description of the channel</td>
					<td>&lt;empty&gt;</td>
				</tr>
				<tr>
					<td>Channel Access Model</td>
					<td>pubsub#access_model</td>
					<td>"whitelist"</td>
					<td>The channel subscriber model</td>
					<td>Dependent on Node</td>
				</tr>
				<tr>
					<td>Default Affiliation</td>
					<td>Buddycloud#default_affiliation</td>
					<td>"publisher"</td>
					<td>The role given to new channel followers</td>
					<td>Dependent on Channel Type</td>
				</tr>
				<tr>
					<td>Channel Type</td>
					<td>Buddycloud#channel_type</td>
					<td>"personal"</td>
					<td>The type of this channel</td>
					<td>N/A</td>
				</tr>
				<tr>
					<td>Channel Creation Date</td>
					<td>pubsub#creation_date</td>
					<td>"2011-01-31T23:59:42"</td>
					<td>When the channel was created in ISO 8601 time format</td>
					<td></td>
				</tr>
			</table>
			<section3 topic="Channel Access Model" anchor="preliminaries-channelmetadata-accessmodel">
				<table caption="Channel Access Models">
					<tr>
						<th>Access Model</th>
						<th>Description</th>
					</tr>
					<tr>
						<td>"authorise"</td>
						<td>The channel is only viewable by it's producer, followers,
							followers+post and moderators.</td>
					</tr>
					<tr>
						<td>"open"</td>
						<td>Anyone can view the channel.</td>
					</tr>
				</table>
			</section3>
			<section3 topic="Channel Affiliations" anchor="preliminaries-channelmetadata-affiliations">
				<p>Buddycloud
					channel affiliations are mapped onto &xep0060;
					node affiliations. 
				</p>
				<table caption="Channel Affiliations">
					<tr>
						<th>XEP-0060 Affiliation</th>
						<th>Buddycloud Affiliation</th>
						<th>Description</th>
						<th>Required?</th>
					</tr>
					<tr>
						<td>Owner</td>
						<td>owner</td>
						<td>The channel owner. Full access rights</td>
						<td>REQUIRED</td>
					</tr>
					<tr>
						<td>-</td>
						<td>moderator</td>
						<td>An entity which has follower+post rights, rights to manage the
							affiliation of entites with the node (except changing ownership),
							and rights to manage the subscriptions of entities with the node</td>
						<td>REQUIRED</td>
					</tr>
					<tr>
						<td>Publisher</td>
						<td>follower+post</td>
						<td>Entity can view posts and replies, publish new posts, and
							publish replies to posts.</td>
						<td>REQUIRED</td>
					</tr>
					<tr>
						<td>Member</td>
						<td>follower</td>
						<td>Entity can view posts and replies for whitelist and open
							channels, but cannot publish new posts or replies.</td>
						<td>REQUIRED</td>
					</tr>
					<tr>
						<td>None</td>
						<td>none</td>
						<td>Entity can view posts and replies for open channels, but
							cannot publish new posts or replies.</td>
						<td>REQUIRED</td>
					</tr>
					<tr>
						<td>Outcast</td>
						<td>outcast</td>
						<td>Entity cannot view any posts or replies, and cannot publish
							new posts or replies.</td>
						<td>RECOMMENDED</td>
					</tr>
				</table>
				<section4 topic="Default Affiliations"
					anchor="preliminaries-channelmetadata-affiliations-default">
				</section4>
			</section3>
		</section2>
	</section1>
	<section1 topic='Entity Use Cases' anchor='entityusecases'>
		<section2 topic='Service Discovery' anchor='entityusecases-servicediscovery'>
			<p>Service discovery happens per domain, and is a multi step process.
			</p>
			<p>To discover the channels component for a domain, the entity first
				sends an items discovery request to the domain to discover all the
				available components
			</p>
			<example caption="The Entity sends a disco#items request to the domain">
	<![CDATA[
	<iq type='get'
		from='juliet@capulet.lit/client'
		to='capulet.lit'
		id='items1'>
		<query xmlns='http://jabber.org/protocol/disco#items'/>
	</iq>
	]]>
</example>
			<p>The server replies with the list of available components, along
				with their associated JIDs.
			</p>
			<example caption="The server replies with a list of available components.">
	<![CDATA[
	<iq type='result' from='capulet.lit' to='juliet@capulet.lit/BuddycloudApp'
		id='items1'>
		<query xmlns='http://jabber.org/protocol/disco#items'>
			<item jid='muc.capulet.lit' name='Chatrooms' />
			<item jid='buddycloud.montague.lit' name='Buddycloud Server' />
		</query>
	</iq>
	]]>
</example>
			<p>The entity then iterates through the &lt;item/&gt; elements,
				sending an info discovery request to each jid. 
			</p>
			<example caption="The Entity sends a disco#info request to each component">
	<![CDATA[
	<iq type='get'
		from='juliet@capulet.lit/BuddycloudApp'
		to='channels.capulet.lit'
		id='info1'>
		<query xmlns='http://jabber.org/protocol/disco#info'/>
	</iq>
	]]>
</example>
			<p>Each component replies with its identity. The channels component
				has an identity of category 'pubsub' and type 'channels'.
			</p>
			<p>
				A domain MUST only host one component with an identity of category
				'pubsub' and type 'channels'. <!-- Really? - just one? -->
			</p>
			<example caption="The Buddycloud component replies with its identity"> <!-- is this response really correct? - would we get register back? -->
	<![CDATA[
<iq type='result' from='buddycloud.capulet.lit' to='juliet@capulet.lit/BuddycloudApp'
	id='info2'>
	<query xmlns='http://jabber.org/protocol/disco#info'>
		<identity category='pubsub' type='channels' />
		<identity category='pubsub' type='inbox' />
		<feature var='jabber:iq:register' />
		<feature var='http://jabber.org/protocol/disco#info' />
	</query>
</iq>
	]]>
</example>
		</section2>
		<section2 topic='Verify the Authority of a Server for a JID'
			anchor='entityusecases-verifyserver'>
			<p>It is necessary to verify that a given Channel Server is a
				channel's home server for a given JID. For example, an Entity may
				wish to verify that the JID 'buddycloud.capulet.lit' is the
				authoritative Home Server for the JID 'juliet@capulet.lit'.
			</p>
			<p>
				The Channel Server SHOULD do this by discovering the Channel Server
				for the JID using
				<link url='#entityusecases-servicediscovery'>Channel Server Discovery</link>
				, but an implementation MAY choose to ascertain this mapping by
				other means. This mapping SHOULD be cached for later use.
			</p>
			<p>
				The Channel Server MUST then apply the Nameprep profile to the
				domains (as defined in
				<link url='http://tools.ietf.org/html/rfc5891'>IDNA</link>
				) before comparing the domain portions of the two JIDs
			</p>
		</section2>
		<section2 topic='Register with the Service' anchor='entityusecases-register'>
			<p>If the jid doesn't already have a Personal Channel on the service,
				one can be created. The Buddycloud server will then also setup the
				associated geoloc and mood nodes and ensure that the nodes have the
				correct default permissions.
			</p>
			<example caption="The Service Advertises the Registration Feature">
	<![CDATA[
	<feature var='jabber:iq:register'/>
	]]>
</example>
			<example caption="An Entity Registers with the Service">
	<![CDATA[
	<iq from="juliet@capulet.lit/BuddycloudApp" to="buddycloudserver.capulet.lit" type="set">
		<query xmlns="jabber:iq:register"/>
	</iq>
	]]>
</example>
		</section2>
	</section1>
	<section1 topic='Publisher Use Cases' anchor='publisherusecases'>
		<section2 topic='Post to a Channel' anchor='publisherusecases-post'>
			<p>Posting to a channel implies a role of "follower+post, moderator
				or producer"
			</p>
			<example caption="A Publisher Posts to a Channel">
	<![CDATA[
<iq from="romeo@montague.lit/BuddycloudApp" to="buddycloud.montague.lit"
	type="set" id="publish:20">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<publish node="/user/juliet@capulet.lit/posts">
			<item>
				<entry xmlns="http://www.w3.org/2005/Atom">
					<published>2010-01-06T21:41:32Z</published>
					<content type="text">Wherefore art thou?</content>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Verona, Italy</text>
						<locality>Verona</locality>
						<country>Italy</country>
					</geoloc>
				</entry>
			</item>
		</publish>
	</pubsub>
</iq>
	]]>
</example>
			<p>The Local Server relays the &lt;publish/&gt; request to the Remote
				Server, along with &lt;actor/&gt; information.</p>
			<example caption="The Local Server relays the request to the Remote Server">
		<![CDATA[
<iq from="buddycloud.montague.lit" to="buddycloud.capulet.lit" type="set"	id="publish:21">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<publish node="/user/juliet@capulet.lit/posts">
			<item>
				<entry xmlns="http://www.w3.org/2005/Atom">
					<published>2010-01-06T21:41:32Z</published>
					<content type="text">Wherefore art thou?</content>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Verona, Italy</text>
						<locality>Verona</locality>
						<country>Italy</country>
					</geoloc>
				</entry>
			</item>
		</publish>
		<actor xmlns='http://buddycloud.org/v1'>romeo@montague.lit</actor>
	</pubsub>
</iq>
		]]>
</example>
			<p>The Remote Server then checks that:</p>
			<ul>
				<li>The
					'from' JID is authoritative for the &actor;
				</li>
				<li>The &lt;actor/&gt; is authorised to post to the Node</li>
			</ul>
			<p>The server then stores the Post against the Node, and responds.
			</p>
			<example caption="The Remote Server responds to the Post request">
		<![CDATA[
<iq from="buddycloud.capulet.lit" to="buddycloud.montague.lit" type="result"
	id="publish:21">
	<pubsub xmlns='http://jabber.org/protocol/pubsub'>
		<publish node='/user/romeo@montague.lit/posts'>
			<item id='123-456-789' />
		</publish>
	</pubsub>
</iq>
		]]>
</example>
			<example caption="The Local Server relays the Response back to the Client">
		<![CDATA[
<iq from="buddycloud.montague.lit" to="romeo@montague.lit/BuddycloudApp"
	type="result" id="publish:20">
	<pubsub xmlns='http://jabber.org/protocol/pubsub'>
		<publish node='/user/juliet@capulet.lit/posts'>
			<item id='123-456-789' />
		</publish>
	</pubsub>
</iq>
		]]>
</example>
			<section3 topic='Content normalization' anchor='publisherusecases-post-normalization'>
				<p>When posting to a Channel the Server MUST apply the following
					rules to the ATOM payload:
				</p>
				<ul>
					<li>The entry/author/uri MUST be set to the acct: account of the
						entity that is actually posting to the channel. This should be the
						bare jid.
					</li>
					<li>Upon a new entry the entry/published timestamp MUST be set to
						the current server time (often more accurate than client clock)
					</li>
					<li>Upon overwriting an existing entry, the entry/published SHOULD
						be copied from the old version and entry/updated SHOULD be set to
						the current server time
					</li>
					<li>The entry/id element SHOULD be updated to reflect the PubSub
						content model
					</li>
					<li>Any conversation thread information MAY be checked for existing
						references, and possibly deny posting with missing context
					</li>
					<li>The entry/content MAY be used for spam filtering, especially
						for posts from non-channel-owners
					</li>
					<li>Missing Activity Streams constructs may be replaced by verb
						post or comment (depending on presence of thr:in-reply-to)
					</li>
				</ul>
				<p>Note: Add something about post size restrictions</p>
				<p>Note: in a decentralized system not only content-hosting servers
					may validate content.
				</p>
			</section3>
		</section2>
		<section2 topic='Reply to a Post' anchor='publisherusecases-replytopost'>
			<p>Replying to a Post is similar to creating a new Post with the
				following exceptions:
			</p>
			<ul>
				<li>The &lt;activity:object-type/&gt; MUST be comment</li>
				<li>The &lt;entry/&gt; element MUST contain an &lt;in-reply-to/&gt;
					element, qualified by the 'http://purl.org/syndication/thread/1.0'
					namespace containing the ItemID of the primary Post 
				</li>
			</ul>
			<example caption="A Publisher Replies to a Post">
		<![CDATA[
<iq from="juliet@capulet.lit/mobile" to="buddycloud.capulet.lit"
	type="set" id="publish:22">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<publish node="/user/juliet@capulet.lit/posts">
			<item>
				<entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
					<published>2010-01-06T21:41:32Z</published>
					<author>
						<name>juliet@capulet.lit</name>
						<jid xmlns="http://buddycloud.com/atom-elements-0">juliet@capulet.lit</jid>
					</author>
					<content type="text">Test</content>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Verona, Italy</text>
						<locality>Verona</locality>
						<country>Italy</country>
					</geoloc>
					<thr:in-reply-to ref='123-456-789' />
				</entry>
			</item>
		</publish>
	</pubsub>
</iq>
		]]>
</example>
			<section3 topic='Error Conditions' anchor='publisherusecases-replytopost-errors'>
				<section4 topic='The client attempts to post a Reply to a Reply'
					anchor='publisherusecases-replytopost-errors-replytoreply'>
					<p>Buddycloud
						allows a single level of replies to posts, so if a request is
						received to post a reply to a reply then the server MUST respond
						with a &badrequest;
						error, which SHOULD include a pub-sub specific
						&lt;invalid-payload/&gt; error. 
					</p>
					<example caption='The server rejects a reply to a reply'>
	<![CDATA[
<iq type='error' from='buddycloud.capulet.lit' to='juliet@capulet.lit/BuddycloudApp'
	id='publish1'>
	<error type='modify'>
		<bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas' />
		<invalid-payload xmlns='http://jabber.org/protocol/pubsub#errors' />
	</error>
</iq>
	]]> </example>
				</section4>
			</section3>
		</section2>
		<section2 topic='Delete a Post' anchor='publisherusecases-deletepost'>
			<p>The client sends a &lt;retract/&gt; request to the Local Inbox 
			</p>
			<example
				caption="The Client sends a Delete Post request to their Local Server">
		<![CDATA[
<iq from="romeo@montague.lit/mobile" to="buddycloud.montague.lit"
	type="set" id="retractitem:32">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<retract node="/user/juliet@capulet.lit/posts" notify="1">
			<item id="123-456-790" />
		</retract>
	</pubsub>
</iq>
		]]>
</example>
			<p>The
				Local Server relays the request to the Remote Server, attaching &actor;
				information. 
			</p>
			<example
				caption="The Client sends a Delete Post request to their Local Server">
		<![CDATA[
<iq from="romeo@montague.lit/mobile" to="buddycloud.montague.lit"
	type="set" id="retractitem:32">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<retract node="/user/juliet@capulet.lit/posts" notify="1">
			<item id="123-456-790" />
		</retract>
	</pubsub>
</iq>
		]]>
</example>
			<p>Server replies</p>
			<example caption="The Server replies to a Delete Post request">
		<![CDATA[
		<iq from="juliet@capulet.lit/BuddycloudApp" to="buddycloudserver.capulet.lit" type="result" id="retractitem:32"/>
		]]>
</example>
			<p>A retraction message is sent to all online clients, along with an
				Atom tombstone to replace the deleted post
			</p>
			<example
				caption="The Server send a Retraction Notification to all Subscribers to the Channel">
		<![CDATA[
<message from="buddycloudserver.capulet.lit" id="bc:MGV3B"
	to="imranraza@capulet.lit">
	<event xmlns="http://jabber.org/protocol/pubsub#event">
		<items node="/user/juliet@capulet.lit/posts">
			<retract id="1291048772456" />
			<item id="1291048772456">
				<deleted-entry xmlns="http://purl.org/atompub/tombstones/1.0"
					ref="xmpp:channels.capulet.lit?pubsub;action=retrieve;node=/user/juliet@capulet.lit/posts;item=1291048772456"
					when="2012-07-01T15:08:32.950Z">
					<updated>2012-07-01T15:08:32.950Z</updated>
					<id xmlns="http://www.w3.org/2005/Atom">1291048772456</id>
					<link xmlns="http://www.w3.org/2005/Atom"
						href="xmpp:channels.capulet.lit?pubsub;action=retrieve;node=/user/juliet@capulet.lit/posts;item=1291048772456"
						rel="self" />
					<published xmlns="http://www.w3.org/2005/Atom">2012-07-01T15:08:30.922Z</published>
					<object xmlns="http://activitystrea.ms/spec/1.0/">
						<object-type>comment</object-type>
						.
					</object>
					<verb xmlns="http://activitystrea.ms/spec/1.0/">post</verb>
					.
				</deleted-entry>
				.
			</item>
			.
		</items>
		.
	</event>
</message>
	]]>
</example>
		</section2>
	</section1>
	<section1 topic='Subscriber Use Cases' anchor='subscriberusecases'>
		<section2 topic='Subscribe to a Channel' anchor='subscriberusecases-subscribe'>
			<p>Channel followers should send subscription requests to their Local
				Inbox, even for remote channels.
			</p>
			<example caption="Client sends Subscription Request to their Local Inbox">
	<![CDATA[
<iq type="set" from="romeo@montague.lit/client" to="buddycloud.montague.lit"
	id="sub1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<subscribe node="/users/juliet@capulet.lit/posts" jid="romeo@montague.lit" />
	</pubsub>
</iq>
		]]>
</example>
			<p>The Local Inbox then Subscribes to the Remote Nodes on the
				Subscriber's behalf.
			</p>
			<example caption="The Local Inbox Subscribes to the Remote Server">
		<![CDATA[
<iq type="set" from="buddycloud.montague.lit" to="buddycloud.capulet.lit"
	id="sub2">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<subscribe node="/users/juliet@capulet.lit/posts" jid="romeo@montague.lit" />
		<actor xmlns="http://buddycloud.org/v1">romeo@montague.lit</actor>
	</pubsub>
</iq>
]]>
</example>
			<p>The remote service checks the actor for permission.</p>
			<p>
				The
				<em>@jid</em>
				attribute is purely decorative to comply with XEP-0060. It is not
				the actual notification listener (in that case the inbox instead of
				the user himself), but the user that wishes to subscribe. Use of the
				<em>&lt;actor/&gt;</em>
				element is more generic and applies to a variety of other requests
				that require authorization.
			</p>
			<p>Upon successful subscription/unsubscription, the inbox SHOULD keep
				track if there's at least one subscription to the node with the
				inbox itself as listener, allowing it to answer read queries from
				only its cache.
			</p>
			<p>Inbox then receives acknowledgement for subscription request, and
				relays it to the client:
			</p>
			<example caption="The Remote Inbox acknowledges the Subscription Request">
<![CDATA[
<iq type="result"
	from="buddycloud.capulet.lit"
	to="buddycloud.capulet.lit"
	id="sub2">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<subscription node="/users/juliet@capulet.lit/posts" jid="romeo@montague.lit" subscription="subscribed"/>
		</pubsub>
	</iq>
	]]>
</example>
			<example
				caption="The Local Inbox replays the Subscription Request acknowledgement to the Client">
	<![CDATA[
<iq type="result"
	from="buddycloud.capulet.lit"
	to="romeo@montague.lit/client"
	id="sub1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
    <subscription node="/users/juliet@capulet.lit/posts" jid="romeo@montague.lit" subscription="subscribed"/>
  </pubsub>
</iq>
		]]>
</example>
			<p>Subscribed inboxes and clients are also notified:</p>
			<example caption="The Remote Inbox notifies Channel Subscribers">
		<![CDATA[
<message from="buddycloud.capulet.lit" to="romeo@montague.lit"
	type="headline">
	<event xmlns="http://jabber.org/protocol/pubsub#event">
		<subscription node="/users/juliet@capulet.lit/posts"
			jid="romeo@montague.lit" subscription="subscribed" />
	</event>
</message>
		]]>
</example>
		</section2>
		<section2 topic='Retrieve Recent Posts from all Subscribed Channels'
			anchor='subscriberusecases-retrieverecentposts'>
			<p>
				Clients that need to access recent posts in all the followed
				channels may use the quick synchronization mechanism. This can only
				be used by authenticated users. <!-- what is the quick sync ? -->
				.
			</p>
			<p>Client sends:</p>
			<example caption="An Entity requests Recent Posts">
		<![CDATA[
<iq from="juliet@capulet.lit/BuddycloudApp" to="buddycloudserver.capulet.lit" type="get" id="ri1">
  <pubsub xmlns="http://jabber.org/protocol/pubsub">
	  <recent-items xmlns="http://buddycloud.org/v1"
		  since="2012-12-04T23:36:51.123Z"
		  max="50"/>
	</pubsub>
</iq>
]]>
</example>
			<p>The servers responds with items from the subscribed channels:
			</p>
			<ul>
				<li>items from the /posts nodes only</li>
				<li>updated after since, newest items first, required</li>
				<li>at most max per channel, required</li>
				<li>RSM must be used to page through results</li>
			</ul>
		</section2>
		<section2 topic='Receive a New Post Notification' anchor='subscriberusecases-newpostnotification'>
			<p>Subscribed inboxes are always notified. Online clients
				automatically receive new posts from the inbox
			</p>
			<example caption="New Post Notification">
<![CDATA[
<message type="headline" id="bc:GfLwH" from="buddycloudserver.capulet.lit"
	to="31941515521289471453412508@anon.buddycloud.com/2906694851289471453813745">
	<event xmlns="http://jabber.org/protocol/pubsub#event">
		<items node="/user/juliet@capulet.lit/posts">
			<item id="1291048810046">
				<entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
					<author>
						<name>Dirk</name>
						<jid xmlns="http://buddycloud.com/atom-elements-0">fahrertuer@capulet.lit</jid>
						<affiliation xmlns="http://buddycloud.com/atom-elements-0">moderator</affiliation>
					</author>
					<content type="text">A comment, wondering what all this testing
						does</content>
					<published>2010-11-29T16:40:10Z</published>
					<updated>2010-11-29T16:40:10Z</updated>
					<id>/user/juliet@capulet.lit/posts:1291048810046</id>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Bremen, Germany</text>
						<locality>Bremen</locality>
						<country>Germany</country>
					</geoloc>
					<thr:in-reply-to ref="1291048772456" />
				</entry>
			</item>
		</items>
	</event>
</message>
]]>
</example>
		</section2>
		<section2 topic='Retrieve all Posts for a Node' anchor='subscriberusecases-allposts'>
			<p>Node items are ordered newest first. The Result Set Management
				elements after and before are not related to timestamps but this
				ordering!
			</p>
			<p>Client sends:</p>
			<example caption="Client requests all Posts">
<![CDATA[
<iq type="get"
	from="juliet@capulet.lit/BuddycloudApp"
	to="buddycloudserver.capulet.lit"
	id="items1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<items node="/user/kitteh@capulet.lit/posts"/>
	</pubsub>
</iq>
]]>
</example>
			<p>Server responds:</p>
			<example caption="The Server responds with all Posts">
<![CDATA[

<iq type="result" from="buddycloudserver.capulet.lit" to="juliet@capulet.lit/BuddycloudApp"
	id="items1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<items node="/user/kitteh@capulet.lit/posts">
			<item id="1291048810046">
				<entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
					<author>
						<name>Dirk</name>
						<jid xmlns="http://buddycloud.com/atom-elements-0">fahrertuer@capulet.lit</jid>
						<affiliation xmlns="http://buddycloud.com/atom-elements-0">moderator</affiliation>
					</author>
					<content type="text">A comment, wondering what all this testing
						does</content>
					<published>2010-11-29T16:40:10Z</published>
					<updated>2010-11-29T16:40:10Z</updated>
					<id>/user/juliet@capulet.lit/posts:1291048810046</id>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Bremen, Germany</text>
						<locality>Bremen</locality>
						<country>Germany</country>
					</geoloc>
					<thr:in-reply-to ref="1291048772456" />
				</entry>
			</item>
			<!-- [more items...] -->
			<item id="1131048810046">
				<entry xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0">
					<author>
						<name>Kittycat</name>
						<jid xmlns="http://buddycloud.com/atom-elements-0">kitteh@capulet.lit</jid>
						<affiliation xmlns="http://buddycloud.com/atom-elements-0">owner</affiliation>
					</author>
					<content type="text">I"m in ur channel, meowing federatedly
					</content>
					<published>2009-08-12T16:40:10Z</published>
					<id>/user/juliet@capulet.lit/posts:1131048810046</id>
					<geoloc xmlns="http://jabber.org/protocol/geoloc">
						<text>Home basket</text>
						<locality>Munich</locality>
						<country>Germany</country>
					</geoloc>
				</entry>
			</item>
		</items>
		<set xmlns="http://jabber.org/protocol/rsm">
			<first>1291048810046</first>
			<last>1131048810046</last>
			<count>19827</count>
		</set>
	</pubsub>
</iq>
]]>
</example>
			<p>Client can then request older items for pagination or filling its
				cache:
			</p>
			<example caption="Client retrieves further Posts">
<![CDATA[
<iq type="get"
	from="juliet@capulet.lit/BuddycloudApp"
	to="buddycloudserver.capulet.lit"
	id="items2">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<items node="/user/kitteh@capulet.lit/posts"/>
		<set xmlns="http://jabber.org/protocol/rsm">
      <max>1200</max>
      <after>1131048810046</after>
		</set>
	</pubsub>
</iq>
]]>
</example>
			<p>Result Set Management is strongly needed for chunking information.
				Even if a user is requesting 10000 items, a Buddycloud server should
				never send stanzas exceeding 64KB, or else XMPP servers will kill
				the (component or s2s) connection.
			</p>
		</section2>
		<section2 topic="Retrieve All Replies to a Single Post">
			<p>This stanza retrieve all replies from a single post. It is useful
				in cases the user has new replies in old posts, so that he does not
				need to look down the node stream to fetch old replies. This can
				only be used by authenticated users. The attrs node and item_id are
				mandatory.
			</p>
			<p>Client sends:</p>
			<example caption="Client requests all Replies to a Post">
<![CDATA[
<iq type="get" from="juliet@capulet.lit/BuddycloudApp" to="buddycloudserver.capulet.lit" id="ri1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<replies xmlns="http://buddycloud.org/v1" node="/user/juliet@capulet.lit/posts" item_id="38efced3-5462-49af-ba83-9f1d0a753a93"/>
	</pubsub>
</iq>
]]>
</example>
			<p>The servers responds with replies to that item</p>
			<ul>
				<li>RSM must be used to page through results</li>
			</ul>
			<example
				caption="Server responds with all Replies to a Post, paged as required">
<![CDATA[
<iq type="result" from="buddycloudserver.capulet.lit"
	to="juliet@capulet.lit/BuddycloudApp" id="ri1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<items>
			<item id="1291048810046">
				<entry>...</entry>
			</item>
			<item id="1287390194809">
				<entry>...</entry>
			</item>
			...
		</items>
		<set xmlns="http://jabber.org/protocol/rsm">
			<first>/user/tybalt@capulet.lit/posts;1291048810046</first>
			<last>/user/peter@capulet.lit/posts;1131048810046</last>
			<count>19827</count>
		</set>
	</pubsub>
</iq>
]]>
</example>
		</section2>
		<section2 topic='Retrieve Entire Thread From a Single Post'>
			<p>
				This stanza retrieves the entire Thread for a post. It is useful for
				filling in all the threads from the
				<link url="subscriberusecases-retrieverecentposts">Recent Posts</link>
				feed which returns recent replies without the original post (or
				other replies).
			</p>
			<p>Client sends the request to their Local Server, giving the ItemID
				of either the Primary Post or any Reply within the Thread:
			</p>
			<example caption="Client requests entire Thread from a Post">
<![CDATA[
<iq type="get" from="romeo@montague.lit/BuddycloudApp" to="buddycloud.montague.lit" id="thread1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<thread xmlns="http://buddycloud.org/v1" node="/user/juliet@capulet.lit/posts" item_id="1234567891"/>
	</pubsub>
</iq>
]]>
</example>
			<p>The Remote Server responds with all Posts from the entire Thread,
				including the Primary Post and all Replies to that Post.
			</p>
			<p>The Remote Server MUST order the posts in reverse-chronological
				order, with the newest post first.
			</p>
			<example
				caption="Server responds with all Replies to a Post including full Payloads, paged as required">
		<![CDATA[
<iq type="result" from="buddycloud.capulet.lit" to="juliet@capulet.lit/BuddycloudApp" id="thread1">
	<pubsub xmlns="http://jabber.org/protocol/pubsub">
		<items>
			<item id="/user/juliet@capulet.lit/posts;1234567892">
				<entry>
					...
					<thr:in-reply-to ref='1234567890' />
				</entry>
			</item>
			<item id="/user/juliet@capulet.lit/posts;1234567891">
				<entry>
					...
					<thr:in-reply-to ref='1234567890' />
				</entry>
			</item>
			<item id="/user/juliet@capulet.lit/posts;1234567890">
				<entry> ...
				</entry>
			</item>
			...
		</items>
		<set xmlns="http://jabber.org/protocol/rsm">
			<first>/user/juliet@capulet.lit/posts;1234567892</first>
			<last>/user/juliet@capulet.lit/posts;1234567890</last>
			<count>186</count>
		</set>
	</pubsub>
</iq>
		]]>
</example>
		</section2>
	</section1>
	<section1 topic='Owner Use Cases' anchor='ownerusecases'>
		<section2 topic='Create a Channel' anchor='ownerusecases-createchannel'>
			<p>???</p>
		</section2>
		<section2 topic='Change a Subscriber&quot;s Affiliation'
			anchor='ownerusecases-changeaffiliation'>
			<p>
				In order to modify the affiliation the owner MUST send an IQ set
				containing the modified affiliation or affiliations according to
				<link
					url='http://xmpp.org/extensions/xep-0060.html#owner-affiliations-modify'>Modify Affiliation</link>
				of &xep0060;
				for the '/posts' node of the channel. The Channel Server then
				updates the affiliation of other Channel Nodes according to
				<link url='#rules-nodeaffiliations'>Maintain Similar Affiliations across Channel Nodes</link>
			</p>
		</section2>
	</section1>
	<section1 topic='Business Rules' anchor='rules'>
		<section2 topic='Maintain Similar Affiliations across Channel Nodes'
			anchor='rules-nodeaffiliations'>
			<p>A Channel Server MUST maintain similar affiliations for a
				subscribed entity across all the Nodes of a Channel.
			</p>
			<p>To achieve this a Client MUST only update the affiliation of the
				/posts Channel Node. The Channel Server MUST then maintain the
				affiliation of the other Channel Nodes appropriately according to
				the following table:
			</p>
			<table caption="Node Affiliation Mappings">
				<tr>
					<th>Affiliation set for the /posts Channel Node</th>
					<th>Affiliation implied for the other Channel Nodes</th>
				</tr>
				<tr>
					<td>owner</td>
					<td>owner</td>
				</tr>
				<tr>
					<td>moderator</td>
					<td>follower</td>
				</tr>
				<tr>
					<td>follower+post</td>
					<td>follower</td>
				</tr>
				<tr>
					<td>follower</td>
					<td>follower</td>
				</tr>
				<tr>
					<td>none</td>
					<td>none</td>
				</tr>
				<tr>
					<td>outcast</td>
					<td>outcast</td>
				</tr>
			</table>
			<p>Note that this only applies to Personal Channels as Topic Channels
				only have a /posts Node
			</p>
		</section2>
	</section1>
	<section1 topic='Implementation Notes' anchor='impl'>
		<section2 topic='Timestamp Preservation' anchor='impl-timestamp'>
			<p>Server-to-server syncing should always preserve items, config,
				subscription, and affiliation timestamps. Otherwise a resync would
				cause MAM to send too much to clients.
			</p>
		</section2>
		<section2 topic='Inbox Caching' anchor='impl-caching'>
			<p>It is generally desirable for an Inbox to maintain a local cache
				of all Node and Item data for any Remote Nodes to which its Local
				entities are subscribed. This is to help improve the response times
				for users.
			</p>
			<p>However, some servers may be required to operate in a constrained
				environment where it is not practical to cache some or all of this
				data. Any remote data which is not cached will therefore need to be
				fetched from the Remote Servers each time it is requested which will
				impact the user experience.
			</p>
			<p>The logic behind cache management and purging of cached data is up
				to the specific implementation.
			</p>
		</section2>
	</section1>
	<section1 topic='Accessibility Considerations' anchor='access'>
		<p>OPTIONAL.</p>
	</section1>
	<section1 topic='Internationalization Considerations' anchor='i18n'>
		<p>OPTIONAL.</p>
	</section1>
	<section1 topic='Security Considerations' anchor='security'>
		<section2 topic='Address Spoofing' anchor='security-addressspoofing'>
			<p>The XMPP Core protocol defines a method for preventing spoofing of
				the 'from'JID on Server to Server communications which we can rely
				on to ensure that the 'from' server is correct. However, due to the
				multi-step way the Channels Protocol works the 'from' address does
				not reflect the ultimate requesting Entity and so extra rules are
				defined which Channel Servers MUST implement in order to ensure that
				addresses cannot be spoofed.
			</p>
			<section3 topic='Actor Spoofing' anchor='security-addressspoofing-actor'>
				<p>This
					protocol defines the &actor;
					element to carry the JID of the originiator of the request. A
					Channel Server MUST apply the following rule to any incoming Stanza
					qualified by the 'jabber:server' namespace which contains an &actor;
					element. 
				</p>
				<p>The
					Channel Server MUST verify that the 'from' JID is authoritative for
					the &actor;
					JID. This is carried out according to
					<link url='#entityusecases-verifyserver'>Verify the Authority of a Channel Server for a JID</link>
					.
				</p>
				<p>If
					the 'from' address is not the Home Server for the &actor;
					then the Channel Server MUST respond with an &invalidactor;
					error and MAY close the stream. 
				</p>
				<example caption='The from address is not authoritative for the actor'>
<![CDATA[
<iq type='error' from='buddycloud.capulet.lit' to='juliet@capulet.lit/client'
	id='items1'>
	<error type='cancel'>
		<policy-violation xmlns='urn:ietf:params:xml:ns:xmpp-stanzas' />
		<invalid-actor xmlns='http://buddycloud.org/v1#errors' />
	</error>
</iq>
]]> </example>
			</section3>
			<section3 topic='Node Spoofing' anchor='security-addressspoofing-node'>
				<p>A Channel Server relies on incoming notifications to ensure that
					the local cache is kept up to date. The Channel Server therefore
					has to ensure that any notifications received are from the
					Authoritative Server for the Node.
				</p>
				<p>
					The Channel Server MUST verify that the 'from' JID is authoritative
					for the JID portion of the NodeID. This is carried out according to
					<link url='#entityusecases-verifyserver'>Verify the Authority of a Channel Server for a JID</link>
					. .
				</p>
				<p>If
					the 'from' address is not the Authoritative Server for the Node
					then the Channel Server MUST respond with an &invalidnode;
					error and MAY close the stream. 
				</p>
				<example
					caption='The &quot;from&quot; address is not authoritative for the Node'>
<![CDATA[
<iq type='error'
	from='buddycloud.capulet.lit'
	to='rosaline@capulet.lit/client'
	id='items1'>
	<error type='cancel'>
		<policy-violation xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
		<invalid-node xmlns='http://buddycloud.org/v1#errors'/>
	</error>
</iq>
]]> </example>
			</section3>
		</section2>
		<section2 topic='Cross Site Scripting ( XSS )' anchor='security-xss'>
			<p>Clients (especially in Web browsers) SHOULD NOT display rich
				content of entry/content[@type='html' or @type='xhtml'] without
				sanitizing markup and scrubbing JavaScrip.
			</p>
		</section2>
	</section1>
	<section1 topic='IANA Considerations' anchor='iana'>
		<p>REQUIRED.</p>
	</section1>
	<section1 topic='XMPP Registrar Considerations' anchor='registrar'>
		<p>REQUIRED.</p>
	</section1>
	<section1 topic='XML Schema' anchor='schema'>
		<section2 topic='http://buddycloud.org/v1'>
			<code><![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'
	targetNamespace='http://buddycloud.org/v1' elementFormDefault='qualified'>
	<xs:annotation>
		<xs:documentation> The protocol documented by this schema is defined
			in XEP-xxxx: http://xmpp.org/extensions/xep-xxxx.html 
		</xs:documentation>
	</xs:annotation>
	<xs:element name="you-missed-something">
		<xs:complexType>
			<xs:complexContent>
				<xs:restriction base="xs:anyType"></xs:restriction>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="actor" type="xs:string"></xs:element>
	<xs:element name="recent-items">
		<xs:complexType>
			<xs:complexContent>
				<xs:restriction base="xs:anyType">
					<xs:attribute name="since" type="xs:dateTime" />
					<xs:attribute name="max" type="xs:int" />
				</xs:restriction>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="replies">
		<xs:complexType>
			<xs:attribute name="node" type="xs:string" />
			<xs:attribute name="item_id" type="xs:string" />
		</xs:complexType>
	</xs:element>
</xs:schema>
]]>
</code>
		</section2>
		<section2 topic='http://buddycloud.org/v1#errors'>
			<code>
<![CDATA[
<?xml version='1.0' encoding='UTF-8'?>
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema' targetNamespace='http://buddycloud.org/v1#errors' elementFormDefault='qualified'>
<xs:annotation>
	<xs:documentation>
		This namespace is used for error reporting only, as
		defined in XEP-xxxx:
		http://xmpp.org/extensions/xep-xxxx.html
	</xs:documentation>
</xs:annotation>
<xs:element name='invalid-actor' type='empty' />
<xs:element name='invalid-node' type='empty' />
</xs:schema>
]]>
</code>
		</section2>
	</section1>
</xep>
